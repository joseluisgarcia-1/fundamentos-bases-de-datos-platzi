Bienvenida conceptos básicos y contexto histórico de las Bases de Datos

***Clase 1 Bienvenida conceptos básicos y contexto histórico de las Bases de Datos***
- Recomendado:
    https://aukera.es/blog/bases-de-datos-relacionales-vs-no-relacionales/

El almacenamiento en la nube tiene un gran pro comparada con los otros métodos de almacenamiento ya que es accesible desde cualquier parte del mundo. Además es centralizada y puede ser usada por varias personas al mismo tiempo.

Las bases de datos entran cuando hacemos la transición a medios digitales.

Tipos de bases de datos:

Relacionales: En la industria hay varias compañías dedicadas a ser manejadoras de 
    bases de datos relacionales como: 
        SQL Server, Oracle, MariaDB, entre otras.
No relacionales: Todavía están avanzando y existen ejemplos muy distintos 
    como: 
        cassandra, elasticsearch, neo4j, MongoDB, entre otras.

Servicios:

Auto administrados: Es la base de datos que instalas tú y te encargas de actualizaciones, mantenimiento, etc.
Administrados: Servicios que ofrecen las nubes modernas como Azure y no debes preocuparte por mantenimiento o actualizaciones.

Medios digitales:
    - Discos duros
    - Discos de estado sólido
    - Cds

Introducción a las bases de datos relacionales

***Clase 2 Historia de las bases de datos relacionales***
- Para leer:
    https://aukera.es/blog/bases-de-datos-relacionales-vs-no-relacionales/
Las bases de datos surgen de la necesidad de conservar la información más allá de lo que existe en la memoria RAM.

Las bases de datos basadas en archivos eran datos guardados en texto plano, fáciles de guardar pero muy difíciles de consultar y por la necesidad de mejorar esto nacen las bases de datos relacionales. 
Su inventor Edgar Codd dejó ciertas reglas para asegurarse de que toda la filosofía de las bases de datos no se perdiera, estandarizando el proceso.

Recomendado de la clase:
https://www.w3resource.com/sql/sql-basic/codd-12-rule-relation.php
https://www.mindmeister.com/es/1079684487/las-12-reglas-de-codd-del-modelo-relacional?fullscreen=1

Las 12 reglas de Codd: fuente

Regla 0: Regla de fundación.
Regla 1: Regla de la información.
Regla 2: Regla del acceso garantizado.
Regla 3: Regla del tratamiento sistemático de valores nulos.
Regla 4: Catálogo dinámico en línea basado en el modelo relacional.
Regla 5: Regla comprensiva del sublenguaje de los datos.
Regla 6: regla de actualización de vistas.
Regla 7: alto nivel de inserción, actualización, y cancelación.
Regla 8: Independencia física de los datos.
Regla 9: Independencia lógicas de los datos.
Regla 10: Independencia de la integridad.
Regla 11: Independencia de la distribución.
Regla 12: La regla de la no subversión.

***Clase 3 Entidades y atributos***

En este ejemplo o curso, cuando un atributo se lo encierra en dos circulos o doble óvalo se está diciendo que es un atributo multivaluado entonces significado
que tiene más de un valor o multiples valores

- Atributos compuestos porque están compuestos valga la aclaración por otros atributos
- Por convención las entidades se colocan en plural, porque una entidad representa un grupo de estos objetos
- Cuando un atributo tiene un guión debajo del nombre o el nombre subrayado, es un atributo que dentro de la entidad se va identificar de forma única
entonces lo identifican de manera única dentro del conjunto o de la entidad
- Entidad fuerte:
    ejemplo:
        Libro
- Entidades débiles:
    - Se representan con un cuadrado pero tienen doble línea, estas entidades pueden ser débiles por dos motivos, uno por identidad y otro por existencia
    las entidades débiles por identidad quiere decir que no se se diferencian entre sí más que por la clave de su entidad fuerte
        ejemplo:
            ejemplares del libro que es la entidad fuerte


***Clase 4 Entidades de Platzi Blog***

Nuestro proyecto será un manejador de Blogpost. Es un contexto familiar y nos representará retos muy interesantes.

- Las entidades recordar que convencionalmente se escriben en plural
    ejemplo de entidad -> post, y sus atributos:
        entidad: posts
        atributos: título, fecha_publicación, contenido, status, etiquetas(atributo multivaluado), id(atributo que dentro de la entidad se va identificar de forma única)  
    ejemplo de entidad -> usuarios, y sus atributos:
        entidad: usuarios
        atributos: login, password, apodo, username, email, id(atributo que dentro de la entidad se va identificar de forma única)

Primer paso: Identificar las entidades
Segundo paso: Pensar en los atributos

***Clase 5 Relaciones***

- Las relaciones es la manera en que empezamos a ligar nuestras diferentes entidades u objetos
    ejemplos:
        las relaciones se representan con un rombo

ejemplo:
----------            ---------
automóvil ----|tiene|--- dueño
----------            ---------
----------                ---------
jugador    ----|pertenece|--- equipo
----------                ---------

Las relaciones nos permiten ligar o unir nuestras diferentes entidades y se representan con rombos. 
Por convención se definen a través de verbos.

Las relaciones tienen una propiedad llamada cardinalidad y tiene que ver con números. 
Cuántos de un lado pertenecen a cuántos del otro lado:

Cardinalidad: 1 a 1
Cardinalidad: 0 a 1
Cardinalidad: 1 a N
Cardinalidad: 0 a N

- ejemplos de cada cardinalidad:
    1 a 1:
        (1)persona tiene (1)datos_contacto
        (1)datos_contacto pertenecen a (1)persona
        por eso decimos que es una relación de 1 a 1 y la podemos representan así: 1:1
        en diagramas físicos los vamos a encontrar así: 
        __|_______________|__
          |               |
y en este también lo representa y se entiende como: 1 y sólo 1 de un lado y 1 y sólo 1 del otro lado     
        _||_______________||_
         ||               ||
          
    0 a 1:

        algunos autores la discuten, sin embargo, se la conoce como 1 a 1 opcional y eso queire decir que no existe alguno de los lados, la podemos representar 0:1
        ejemplo:
            sesion_actual tiene usuario
            la sesion_actual debe tener un usuario, pero el usuario puede que no esté en la sesión en este momento, por lo tanto la cardinalidad se define de 0:1
            y se representa así:
            --|-------|--
            con la línea punteada para indicar que es opcional, o así:
            __|0_______________|__
              |                |
            
    1 a N:
        cabe aclara que índica que en un lado tenemos uno(1) y en otro lado tenemos muchos(N)
            ejemplo:
                persona(1) tiene (N)automóvil
                (1)persona tiene automóvil(N)
                (N)muchos automóviles pertenecen a (1)persona
                
                y se representa así:
            __|_______________0<__
              |                                
              (pate gallina al final)
            __|_______________<__
              |                 
              (pate gallina al final)
            _||_______________|<_
             ||               |
            (pate gallina al final)

    0 a N:

        algunos autores también la discuten, sin embargo, se la conoce como 0 a N opcional y eso quiere decir que no existe alguno de los lados, la podemos representar 0:N
        ejemplo:
            paciente tiene habitacion_hospital
            el hospital tiene 0 pacientes para muchas habitaciones
            y se representa así:
            --|-------<-
            con la línea punteada para indicar que es opcional, o así:
            __|0_______________<__
              |                
***Clase 6 Múltiples muchos***

    N:N
        relación de muchos a muchos
        ejemplo:
            alumno(1) pertenece a (N)clases
            alumno(N) pertenece a (1)clases
        se lo puede representar N:N

***Clase 7 Diagrama ER***

Un diagrama es como un mapa y nos ayuda a entender cuáles son las entidades con las que vamos a trabajar, 
cuáles son sus relaciones y qué papel van a jugar en las aplicaciones de la base de datos.

muchas veces un atributo multivaluado se convierte en una entidad separada, porque si está en muchas partes toma una vida propia

Diagrama Entidad Relación de PlatziBlog:

    usuarios(1) escribe (N)comentarios
    usuarios(1) escribe (N)posts 
    posts(1) tiene (N)comentarios
    posts(N) tiene (1)categorias
    posts(N) tiene (N)etiquetas

***Clase 8 Diagrama Físico:  tipos de datos y constraints***

Texto: 
    Char(n): Este sirve para guardar cadenas de caracteres
    Varchar(n): Este sirve para guardar cadenas de caracteres pero es más dinámico que CHAR la diferencia es la optimización del uso de memoria,
        y si por ejemplo siempre vamos a tener una cadena de 8 caracteres la podemos guardar con un char, pero si la cadena va crecer más se usa varchar
    Text: Sirve para guardar grandes contenidos de texto muy grandes
Números: 
    Integer(n): Para guardar números enteros
    Bigint(n): Es un subtipo de Integer y sirve para guardar números muy muy grandes
    Smallint(n): Es un subtipo de Integer y sirve para guardar números pequeños por ejemplo de 99 o menos
    Decimal(n,s): para guardar números decimales
    Numeric(n,s): 
Fecha/Hora: 
    Date:  Para guardar unicamente la fecha 
    Time: Para guardar unicamente la hora
    Datetime:  Para guardar la fecha, hora y hasta segundos
    Timestamp: Para guardar la fecha, hora y hasta segundos
Lógicos: 
    Boolean: Para guardar True o False, 0 o 1, y se usa para hacer validación entre dos cosas

Constraints(restricciones)
- Not null: Se aegura que la columna no tenga valores nulos, es decir, que ese campo no puede ir vacio o en blanco, y si quieren pasarle un dato así, les da error
- Unique: Se asegura que cada valor en la columna no se repita, es decir, que es uníco en toda la tabla, que solo existe uno con ese valor en la tabla
- Primary Key: Es una combinación de Not Null y Unique, este es una de las más importantes, y cuando colocamos este enla base de datos vamos a tener la garantía
    de que ese campo va ser not null y unique, además nos ayuda a hacer la unión entre una tabla y otra, ó entre una entidad y otra
    es la que en realidad nos ayuda a hacer las relaciones entre entidades
- Foreign Key: Identifica de manera única una tupla en otra tabla, quiere decir llave foránea y es el otro lado de la primary key, y se usa cuando queremos juntar dos tablas
    y decir que esta tabla está relacionada con esta otra lo que hacemos es que la primary key de una tabla se añade como Foreign key en la otra,y debe tener las mismas
    características de la primary key
- Check: Se asegura que el valor en la columna cumpla una condición dada, nos permite generar una regla 
- Default: Coloca un valor por defecto cuando no hay un valor específico, por ejemplo si no viene un valor podemos decir que por defecto traiga un valor 0
- Index: Se crea por columna para permitir búsquedas más rápidas, hay que saber trabajarlos porque genera confusiones

***Clase 9 Diagrama Físico: normalización***

La normalización como su nombre lo indica nos ayuda a dejar todo de una forma normal. Esto obedece a las 12 reglas de Codd y nos permiten separar componentes en la base de datos:

Primera forma normal (1FN): Atributos atómicos (Sin campos repetidos)
Segunda forma normal (2FN): Cumple 1FN y cada campo de la tabla debe depender de una clave única.
Tercera forma normal (3FN): Cumple 1FN y 2FN y los campos que NO son clave, NO deben tener dependencias.
Cuarta forma normal (4FN): Cumple 1FN, 2FN, 3FN y los campos multivaluados se identifican por una clave única.


***Clase 10 Formas normales en Bases de Datos relacionales***

La normalización en las bases de datos relacionales es uno de esos temas que, por un lado es sumamente importante y por el otro suena algo esotérico. Vamos a tratar de entender las formas normales (FN) de una manera simple para que puedas aplicarlas en tus proyectos profesionales.

Primera Forma Normal (1FN)
Esta FN nos ayuda a eliminar los valores repetidos y no atómicos dentro de una base de datos.

Formalmente, una tabla está en primera forma normal si:

Todos los atributos son atómicos. Un atributo es atómico si los elementos del dominio son simples e indivisibles.
No debe existir variación en el número de columnas.
Los campos no clave deben identificarse por la clave (dependencia funcional).
Debe existir una independencia del orden tanto de las filas como de las columnas; es decir, si los datos cambian de orden no deben cambiar sus significados.
Se traduce básicamente a que si tenemos campos compuestos como por ejemplo “nombre_completo” que en realidad contiene varios datos distintos, en este caso podría ser “nombre”, “apellido_paterno”, “apellido_materno”, etc.

También debemos asegurarnos que las columnas son las mismas para todos los registros, que no haya registros con columnas de más o de menos.

Todos los campos que no se consideran clave deben depender de manera única por el o los campos que si son clave.

Los campos deben ser tales que si reordenamos los registros o reordenamos las columnas, cada dato no pierda el significado.

Segunda Forma Normal (2FN)
Esta FN nos ayuda a diferenciar los datos en diversas entidades.

Formalmente, una tabla está en segunda forma normal si:

Está en 1FN
Sí los atributos que no forman parte de ninguna clave dependen de forma completa de la clave principal. Es decir, que no existen dependencias parciales.
Todos los atributos que no son clave principal deben depender únicamente de la clave principal.
Lo anterior quiere decir que sí tenemos datos que pertenecen a diversas entidades, cada entidad debe tener un campo clave separado. Por ejemplo:
Captura de Pantalla 2019-04-30 a la(s) 17.30.27.png

En la tabla anterior tenemos por lo menos dos entidades que debemos separar para que cada uno dependa de manera única de su campo llave o ID. En este caso las entidades son alumnos por un lado y materias por el otro. En el ejemplo anterior, quedaría de la siguiente manera:
Captura de Pantalla 2019-04-30 a la(s) 17.26.28.png

Tercera Forma Normal (3FN)
Esta FN nos ayuda a separar conceptualmente las entidades que no son dependientes.

Formalmente, una tabla está en tercera forma normal si:

Se encuentra en 2FN
No existe ninguna dependencia funcional transitiva en los atributos que no son clave

Esta FN se traduce en que aquellos datos que no pertenecen a la entidad deben tener una independencia de las demás y debe tener un campo clave propio. Continuando con el ejemplo anterior, al aplicar la 3FN separamos la tabla alumnos ya que contiene datos de los cursos en ella quedando de la siguiente manera.

Captura de Pantalla 2019-04-30 a la(s) 17.27.43.png
Captura de Pantalla 2019-04-30 a la(s) 17.27.52.png
Cuarta Forma Normal (4FN)
Esta FN nos trata de atomizar los datos multivaluados de manera que no tengamos datos repetidos entre rows.

Formalmente, una tabla está en cuarta forma normal si:

Se encuentra en 3FN
Los campos multivaluados se identifican por una clave única
Esta FN trata de eliminar registros duplicados en una entidad, es decir que cada registro tenga un contenido único y de necesitar repetir la data en los resultados se realiza a través de claves foráneas.

Aplicado al ejemplo anterior la tabla materia se independiza y se relaciona con el alumno a través de una tabla transitiva o pivote, de tal manera que si cambiamos el nombre de la materia solamente hay que cambiarla una vez y se propagara a cualquier referencia que haya de ella.

Captura de Pantalla 2019-04-30 a la(s) 17.29.00.png
Captura de Pantalla 2019-04-30 a la(s) 17.29.29.png

De esta manera, aunque parezca que la información se multiplicó, en realidad la descompusimos o normalizamos de manera que a un sistema le sea fácil de reconocer y mantener la consistencia de los datos.

Algunos autores precisan una 5FN que hace referencia a que después de realizar esta normalización a través de uniones (JOIN) permita regresar a la data original de la cual partió.

***Clase 11 Diagrama Físico: normalizando Platziblog***

- lo escribí en un cuaderno el diagrama, sin embargo, debo buscar donde hacer el diagrama
- Siempre la llave foranea va quedar donde está la relación de muchos(N)

ejemplos de entidades con sus respectivos atributos:
    usuarios:
        id INTEGER(PK)
        login VARCHAR(30)NN
        password VARCHAR(32)NN
        nickname VARCHAR(40)NN
        email VARCHAR(40) UNIQUE
    el NN es: Not Null
    posts:
        id INTEGER(PK)
        título VARCHAR(150)
        fecha_publicación TIMESTAMP
        contenido TEXT
        status CHAR(8) CHECK IN('activo', 'inactivo')
    comentarios:
        id INTEGER(PK)
        comentario TEXT
    categorias:
        id INTEGER(PK)
        categoria VARCHAR(30)
    etiquetas:
        id INTEGER(PK)
        nombre_etiqueta VARCHAR(30) 

Ahora, cuando se empiezan a hacer las relaciones entre las entidades, se agrega las claves de usuario, Foreign Key(llave foránea)
entonces en las tablas de posts y de usuarios van a aparecer las Foreign Key(llaves foraneas) eso pasa cuando relacionamos las Entidades
con líneas y en la base de datos lo que pasa es que se añade la clave única digamos del usuario como clave foranea en la otra tabla
en el caso de posts tenemos que se nos agregó usuarios_id INTEGER FK que es justamente la llave foranea que viene referenciando el id del usuario que lo creó
y en comentarios también tenemos el usuarios_id INTEGER FK que es justamente la llave foranea que viene referenciando el id del usuario que lo creó

- Cuando tengamos de 1:1 no importa a qué tabla le pongamos la referencia de la otra tabla es indistinto
- Cuando tengamos de 1:N es importante que la tabla donde tengamos la terminación muchos es en donde se pone la llave foranea de la tabla que tiene 1
    por eso tenemos el ejemplo de posts y comentarios REVISAR

- también tenemos el ejemplo de posts(N) tiene (1)categorias, entonces colocamos la llave foranea en la tabla de posts

    usuarios:
        id INTEGER(PK)
        login VARCHAR(30)NN
        password VARCHAR(32)NN
        nickname VARCHAR(40)NN
        email VARCHAR(40) UNIQUE
    el NN es: Not Null
    posts:
        id INTEGER(PK)
        título VARCHAR(150)
        fecha_publicación TIMESTAMP
        contenido TEXT
        status CHAR(8) CHECK IN('activo', 'inactivo')
        usuarios_id INTEGER FK
        categorias_id INTEGER FK
    comentarios:
        id INTEGER(PK)
        comentario TEXT
        usuarios_id INTEGER FK
        posts_id INTEGER FK
    categorias:
        id INTEGER(PK)
        categoria VARCHAR(30)
    etiquetas:
        id INTEGER(PK)
        nombre_etiqueta VARCHAR(30) 

- EXCEPCIÓN: N:N la unión de dos entidades que tienen relación de muchos a muchos,
    ejemplo: posts y etiquetas, qué pasa en este caso?
        esa relación de muchos a muchos lo que pasa es que se rompe y coloca una tabla intermedia, y a esa tabla muchas veces se le llama tabla pivote
        y nos ayuda justamente a mirar cual es la relación enre ambas entidades
    y queda así una tabla así:

    posts_etiquetas
    post_id INTEGER(PK, FK)
    etiqueta_id INTEGER(PK, FK)

RDBMS (MySQL) o cómo hacer lo anterior de manera práctica

***Clase 12 ¿Qué es RDB y RDBMS?***

RDB: Relational Database(Bases de datos relacionales)
RDBMS: Relational Database Management System (Sistema manejador de bases de datos relacionales)
este nos ayuda a cumplir las reglas
ejemplos de RDBMS:
    Mysql
    PostsgreSQL
    Oracle

***Clase 13 Instalación local de un RDBMS (Windows)***

https://dev.mysql.com/downloads/workbench/
https://dev.mysql.com/downloads/mysql/5.7.html

***Clase 14 Instalación local de un RDBMS (Mac)***

https://platzi.com/clases/1566-bd/20207-instalacion-local-de-un-rdbms-mac5139/
tener en cuenta que el workbench hay que descargarlo aparte

***Clase 15 Instalación local de un RDBMS (Ubuntu)***

Visita la dirección de descarga de la versión de comunidad de MySql
https://dev.mysql.com/downloads/mysql/5.7.html#downloads

Dirígete a la sección de selección de descargas y selecciona tu distribución de Linux. En nuestro caso Ubuntu y selecciona posteriormente la versión que estás utilizando actualmente, en nuestro caso 18.04 de 64 bits.
Captura de Pantalla 2019-04-30 a la(s) 17.35.57.png

Más abajo encontrarás las diferentes opciones de descarga existen diversos paquetes dependiendo tus necesidades. En el caso del ejemplo usaremos la versión deb bundle. Da click en el botón Download seleccionado.
Captura de Pantalla 2019-05-14 a la(s) 19.13.24.png

En la siguiente pantalla nos piden que nos registremos o iniciemos sesión, pero ya que solo queremos la descarga daremos click en el link que se encuentre en la parte de abajo.
Captura de Pantalla 2019-04-30 a la(s) 17.36.25.png

Espera a que la descarga concluya.
Al terminar abre el archivo .tar con el desempaquetador de tu preferencia.
Captura de Pantalla 2019-04-30 a la(s) 17.36.37.png

Extrae el contenido en la carpeta de tu preferencia.
Captura de Pantalla 2019-04-30 a la(s) 17.36.48.png

Selecciona el archivo de servidor de comunidad y ábrelo con tu manejador de paquetes instalado.
Captura de Pantalla 2019-04-30 a la(s) 17.36.59.png
Captura de Pantalla 2019-04-30 a la(s) 17.37.07.png

Da click en instalar.
Finalmente puedes ir a la consola o terminal de Ubuntu y escribir el siguiente comando.
sudo mysql
Captura de Pantalla 2019-04-30 a la(s) 17.37.15.png

A continuación deberá aparecer una ventana con el prompt de mysql donde ya puedes comenzar a ejecutar los comandos de las lecciones.

Captura de Pantalla 2019-04-30 a la(s) 17.37.22.png
Nota: recuerda estar seguro que las dependencias para el paquete se cumplen para instalar.
Nota: muchas veces las distribuciones ya cuentan con paquetes en su repositorio, en ese caso también puedes ejecutar el comando:
sudo apt-get install mysql-server

***Clase 16 Clientes gráficos***

Fue una clase para familiarizarnos con MySQL, cómo crear una instancia, esquemas, entre otros apuntes

***Clase 17 Servicios administrados***

Hoy en día muchas empresas ya no tienen instalado en su servidor los RDBMS si no que los contratan a otras personas y estos servicios se les llama
servicios cloud o servicios administrados, lo que significa que un servicio cloud, la empresa no se ocupa realmente de administrar la base de datos
colocarles parches de seguridad, mantenerla, computadores, entre otros requerimientos.
Algunos de los servicios donde podemos encontrar ello es con:
    - Amazon - Aws
    - Azure - Microsoft
    - Google cloud
    - etc.
Muchos de los servicios ya están dirigidos más a empresa que ha desarrolladores, aunque para desarrolladores dan una prueba gratuita bastante amplia, y cuando
ya se tiene mucha información o mucho uso de esa app, entonces empiezan a cobrar

Enlace donde vamos a practicar con ese servicio administrado
https://cloud.google.com/cloud-console
aunque no me dejó ingresar porque no tengo tarjeta de crédito :(
SQL hasta en la sopa

***Clase 18 Historia de SQL***

SQL: Structure Query Language(Lenguaje de consultas estructurado)
NOSQL: Not Only Structure Query Language(No uses solo lenguaje de consultas estructurado)

Se crea en un momento en el que trataban de hacer consultas a datos pero no existia una forma realmente estandarizada de hacerlo
entonces por eso se crea SQL, y el objetivo es hacer un solo lenguaje para consultar y no importa el manejador de bases de datos que tengamos
trata de unificarlos todos. Se crea porque las compañías tenían su RDBMS pero no sabían como comunicarse entre ellos y el tratar de programar algo 
que permite la comunicación resultaba muy tedioso, entonces debido a eso se crea el SQL, y una de sus características más importantes 
es que es estructurado, es decir, tiene un estructura muy clara y fija.

Hoy en día aunque hay bases de datos no relacionales, y aunque usan un lenguaje un poco más amplío que el SQL, como base siguen teniendo SQL
por ejemplo:
    Cassandra: Tiene un lenguaje que se llama cql que es muy similar a sql

SQL significa Structured Query Language y tiene una estructura clara y fija. Su objetivo es hacer un solo lenguaje para consultar cualquier manejador de bases de datos volviéndose un gran estándar.

Ahora existe el NOSQL o Not Only Structured Query Language que significa que no sólo se utiliza SQLen las bases de datos no relacionales.

***Clase 19 DDL create***

No está de más aclarar que primero se debe crear la base de datos o schema y luego ir a tables y darle en crear tabla, pero ahí nos da la opción
de crearla manualmente por así decirlo y no con código.

Data Definition Language(Lenguaje de definición de datos):
    - Este nos ayuda a crear la estructura de una base de datos, los cimientos, relaciones, entidades

- Create: Se puede usar el create para crear una base de datos, esquema(schema), tabla, vista, índice, entre otros
- Alter: Con este se puede alterar o modificar datos como tablas, agregando columna o quitando, ó cambiando tipo de dato de la columna, entre otros.
- Drop: Aunque es de mucho cuidado, con este se puede borrar columnas, una tabla, e incluso toda una base de datos.
Lo que se va manejar con el lenguaje DDL por ejemplo son:
    Database: Repositorio de datos que va usar un proyecto
    Table: Son la proyección o la traducción a SQL de las entidades, tanto de entidad relación como el diagrama físico
    View: Es la proyección de los datos de la base de datos de una forma visual entendible para alguien
- Para crear base de datos es así:
    CREATE DATABASE test_db; 
    USE DATABASE test_db;
    test_db es el nombre de la base de datos
    en el primero estamos creando una base de datos
    y en el USE DATABASE test_db lo que decimos es que queremos usar esa base de datos por defecto

- Para crear una tabla tenemos el siguiente ejemplo:
    people será el nombre de la tabla
CREATE TABLE people(
    persona_id int,
    last_name varchar(255),
    firts_name varchar(255),
    address varchar(255),
    city varchar(255),
);

En el MySQL, en el servidor el significado de los datos que toman los atributos:

SQL tiene dos grandes sublenguajes:
DDL o Data Definition Language que nos ayuda a crear la estructura de una base de datos. Existen 3 grandes comandos:

Create: Nos ayuda a crear bases de datos, tablas, vistas, índices, etc.
Alter: Ayuda a alterar o modificar entidades.
Drop: Nos ayuda a borrar. Hay que tener cuidado al utilizarlo.

3 objetos que manipularemos con el lenguaje DDL:
    - Database o bases de datos
    - Table o tablas: Son la traducción a SQL de las entidades
    - View o vistas: Se ofrece la proyección de los datos de la base de datos de forma entendible.

- AI: Auto Incrementado(Auto Increment), lo que quiere decir que cada que agregamos una persona va tomar un valor automáticamente y en secuencia
- Q: UNIQUE


por si queremos hacer la creación de la tabla desde código, quedaría así:

CREATE TABLE `platziblog`.`people` (
  `persona_id` INT NOT NULL AUTO_INCREMENT,
  `last_name` VARCHAR(100) NOT NULL,
  `first_name` VARCHAR(100) NOT NULL,
  `address` VARCHAR(100) NOT NULL,
  `city` VARCHAR(100) NOT NULL,
  PRIMARY KEY (`persona_id`));

***Clase 20 CREATE VIEW y DDL ALTER***

Views(vistas): Tienen que ver con un concpeto avanzado y útil, las vistas lo que hacen es tomar datos de la base de datos y colocarlos en una forma presentable
y convertir en algo que se pueda consultar de manera recurrente, el comando CREATE VIEW tiene dos partes principales
    la primera: luego del CREATE VIEW Asignarle el nombre a la vista y por buena práctica cuando se está creando una vista al nombre de la vista se le coloca una v
    en el nombre para identificar que es una vista lo que se tiene, entonces ejemplo de ese nombre: v_colombia_people

IMPORTANTE:

Como la base de datos que yo tenía para hacer la prueba de la vista no tenía datos, le coloqué datos desde código y usé la siguiente estructura

INSERT INTO people(persona_id, last_name, first_name, address, city)
VALUES ('1', 'Vázquez', 'Israel', 'Calle famosa num 1', 'México'), 
('2','Hernández','Mónica','Reforma 222','México'), 
('3','Alanís','Edgar','Central 1','Monterrey');

y con eso me insertó los datos en la tabla y ya pasé a hacer la prueba de la vista

Los pasos para crear la vista fueron los siguientes:
a la tabla que tiene los datos que en este ejemplo fue people le dí click derecho, y seleccioné "Select rows 1000" cuando le doy ahí
me lleva a la tabla donde tengo los datos y en el espacio de trabajo donde puedo codear me sale lo siguiente
SELECT * FROM platziblog.people; y eso lo copio 
2. de ahí me voy a views en el panel del lado izquiedo, doy click derecho y selecciono create view y eso nos lleva donde se puede codear
y nos coloca un nombre de la vista por defecto el cual vamos a cambiar por el nombre que queramos, y la palabra AS si la dejamos, 
luego pegamos la secuencia select que copiamos antes entonces quedaría algo así:
CREATE VIEW `platzi_people` AS
SELECT * FROM platziblog.people;
despues de ello, le damos en apply y nos arroja lo siguiente:

USE `platziblog`;
CREATE  OR REPLACE VIEW `platzi_people` AS
SELECT * FROM platziblog.people;

y con eso queda la tabla en la tabla vistas con la información

- Para crear una vista con código es así:

USE test_db;
CREATE OR REPLACE VIEW people_platzi AS
SELECT * FROM test_db.people;

En las vistas se puede guardar información de varias tablas y obtener la información exacta, y tiene la gran ventaja
de que estas vistas se mantienen en memoria de tal manera que podemos mantener esta vista al día

- ALTER
ejemplos:
    En este caso le estamos diciendo que se agregue una columna que se llame date_of_birth con el tipo date
        ALTER TABLE people
        ADD date_of_birth date;

    En este caso le estamos diciendo que se altere o modifique el tipo de dato que tiene la columna date_of_birth por year
        ALTER TABLE people
        ALTER COLUMN date_of_birth year;

    En este caso le estamos diciendo que elimine la columna date_of_birth
        ALTER TABLE people
        DROP COLUMN date_of_birth;

Entonces en práctica lo que vamos a hacer es alterar la tabla de people, entonces vamos el panel del lado izquierdo en Tables
seleccionamos la tabla con el click derecho y le damos alter table y nos lleva al grafico donde podemos modificar las tablas
y cuando hacemos los cambios por ejemplo de agregar una columna nos arroja esto
ALTER TABLE `platziblog`.`people` 
ADD COLUMN `date_of_birth` DATETIME NULL AFTER `city`;

y para modificar de nuevo ya sea el tipo de dato u otro dato, hacemos lo mismo en el panel del lado izquierdo

***Clase 21 DDL drop***

Lenguaje de definición de datos(Definition Data Language)

Drop: Para borrar
    ejemplos:
        Para borrar una tabla
            DROP people;
        Para borrar una base de datos
            DROP DATABASE test_db

También para borrar una tabla desde el gráfico podemos ir al menú del lado izquierdo y seleccionar la tabla con click derecho y
escoger la opción drop delete

en código sería algo así por ejemplo:
    DROP TABLE ´platzi_blog´.´people´;

También para borrar un schema desde el gráfico podemos ir al menú del lado izquierdo y seleccionar el schema con click derecho y
escoger la opción drop schema

en código sería algo así por ejemplo:
    DROP DATABASE `platziblog`;
IMPORTANTE:
así creé una base de datos y tablas con código y en el archvio de Query1, que hice fue:
1. Crear la base de datos
2. Decirle a MySQL que use la base de datos creada
3. como ya estoy usando la base de datos creada, entonces le paso que cree la tabla
tener en cuenta como se creó la primary key, hasta este momento no sé si esté bien pero así lo hice a modo de ejemplo
y espero ir puliendo

CREATE DATABASE test_db;
USE test_db;
CREATE TABLE people3(
personas_id INT primary key not null AUTO_INCREMENT,
last_name varchar(100) not null,
first_name varchar(100) not null,
address varchar(100) not null,
city varchar(100) not null
);

ASÍ TAMBIÉN FUNCIONÓ

CREATE DATABASE new;
USE new;
CREATE TABLE people(
persona_id INT NOT NULL AUTO_INCREMENT,
last_name VARCHAR(100) NOT NULL,
first_name VARCHAR(100) NOT NULL,
address VARCHAR(100) NOT NULL,
city VARCHAR(100) NOT NULL,
PRIMARY KEY(persona_id)
);

para colocarle la primary key

DDL(Definition Data Language) Lenguaje de definición de datos

Para eliminar una tabla o base de datos lo podemos hacer con el siguiente comando:

Para eliminar una tabla
    DROP TABLE people;

Para eliminar una base de datos o en ocasiones la base de datos se conoce como esquema(schema)
    cualquiera de los dos sirve
    DROP SCHEMA test_db;
    DROP DATABASE test_db;

En consola lo hacemos así:

desde la app grafica MySQL workbench, podemos ir al menú del lado izquierdo en Tables mirar las tablas que tenemos
la que vamos a borrar la seleccionamos con click derecho y le damos en la opción drop table y con eso la podemos borrar
aunque luego de ejecutar ello, nos arroja un código y es así:
DROP TABLE `test_db`.`people2`;
y si lo queremos hacer directamente con código lo hacemos así:
    DROP TABLE people;
    ó también me funcionó así:
    DROP TABLE test_db.people
    en donde le pasé directamente el nombre exacto de la base de datos y de la tabla y funcionó

desde la app grafica MySQL workbench, podemos ir al menú del lado izquierdo mirar los schemas o bases de datos que tenemos
la que vamos a borrar la seleccionamos con click derecho y le damos en la opción drop schema y con eso la podemos borrar
aunque luego de ejecutar ello, nos arroja un código y es así:
DROP DATABASE `tuto`;

y si lo queremos hacer directamente con código lo hacemos así:
    DROP DATABASE test_db;

- Para crear una vista con código es así:

USE test_db;
CREATE OR REPLACE VIEW people_platzi AS
SELECT * FROM test_db.people;

Está puede ser la sentencia ¡más peligrosa! (????), sobre todo cuando somos principiantes. 
Básicamente borra o desaparece de nuestra base de datos algún elemento.

***Clase 22 DML***

Data Maniupulation Language(DML) Lenguaje de manipulación de datos

sus pilares son:
    - Insert
    - Update
    - Delete
    - Select
Con estos podemos trabajar con la información que contiene una base de datos
    ejemplos de cada pilar:
        - Insert:
            Con este podemos insertar, agregar, adicionar nuevos datos, registro o tupla a nuestra tabla en la base de datos
                ejemplo de estructura:
                    INSERT INTO people (last_name, first_name, address, city)
                    VALUES ('Ronaldo', 'El Fenomeno', 'Leyenda', 'Valladolid');
        
        - Update:
            Actualiza o modifica los datos que ya tenemos:
            Si ya hay un dato que existe lo actualiza, tener en cuenta que este no inserta datos si no existen, actualiza los que están
            Ejemplo de estructura:
                En este le voy a decir que: en la tabla people cambie(SET) el apellido(last_name) por 'Juanfer', la ciudad(City) por 'Buenos Aires'
                en el campo que el persona_id sea igual a 1
                UPDATE people
                SET last_name = 'Juanfer', 'city' = 'Buenos Aires'
                WHERE persona_id = 1;

            Otro ejemplo:                
                En este le voy a decir que: en la tabla people cambie(SET) el primer nombre(first_name) por 'Robert'
                donde la ciudad sea igual a 'Manchester'
                UPDATE people
                SET firts_name = 'Robert'
                WHERE city = 'Manchester'
                Tener cuidado con este porque si tengo muchos usuarios con que su ciudad es Manchester le puede cambiar el dato a todos los usuarios
            
        - Delete:
            Sirve para borrar contenido de una tabla o una tabla también
            Ejemplo de estructura:
                Para borrar un dato nada más es así:
                    DELETE FROM people
                    WHERE persona_id = 1;
                    Si me funcionó, pero si intentaba borrar con otro atributo, si no me dejaba, averiguar por qué
                Para borrar la tabla completa es así:
                    DELETE FROM people
        - Select:
            Se usa mucho esta sentencia, lo que hace es traer información de la base de datos
            Ejemplo de estructura:
                En este ejemplo le estamos diciendo que nos traiga el nombre y apellido de la tabla people
                SELECT first_name, last_name FROM people;


DDL -> Data Definition Language
Ayuda a crear la estructura de una BD.

Create
* Database
* Table
* View
Alter
Drop
DML -> Data Manipulation Language
Ayuda a la manipulacion del contenido

Insert
Update
Delete
Select
Siempre tener cuidado en el orden de los campos donde se le va pasar la información, porque si no, se agrega información en campos que no son

DML trata del contenido de la base de datos. Son las siglas de Data Manipulation Language y sus comandos son:

Insert: Inserta o agrega nuevos registros a la tabla.
Update: Actualiza o modifica los datos que ya existen.
Delete: Esta sentencia es riesgosa porque puede borrar el contenido de una tabla.
Select: Trae información de la base de datos.

***Clase 23 ¿Qué tan standard es SQL?***

La utilidad más grande de SQL fue unificar la forma en la que pensamos y hacemos preguntas a un repositorio de datos. 
Ahora que nacen nuevas bases de datos igualmente siguen tomando elementos de SQL.
Para crear una tabla es así:
    CREATE TABLE people3(
    personas_id INT primary key not null AUTO_INCREMENT,
    last_name varchar(100) not null,
    first_name varchar(100) not null,
    address varchar(100) not null,
    city varchar(100) not null
    );

ASÍ TAMBIÉN FUNCIONÓ, pero si queremos especificar en qué base de datos queremos crear esa tabla, es así:

USE new;
CREATE TABLE people(
persona_id INT NOT NULL AUTO_INCREMENT,
last_name VARCHAR(100) NOT NULL,
first_name VARCHAR(100) NOT NULL,
address VARCHAR(100) NOT NULL,
city VARCHAR(100) NOT NULL,
PRIMARY KEY(persona_id)
);


- Para insertar datos es así:
    INSERT INTO people (last_name, first_name, address, city)
    VALUES ('Ronaldo', 'El Fenomeno', 'Leyenda', 'Valladolid');

- Para traer o ver información hacemos así:
    SELECT firts_name, last_name FROM people;

- Para eliminar la tabla es así:
    DROP TABLE people;

PostsgreSQL:
    Usa casi la misma estructura de MySQL

    \dt: podemos ver la tabla que tenemos en la base de datos


***Clase 24 Creando Platziblog: tablas independientes***

Una buena práctica es comenzar creando las entidades que no tienen una llave foránea.
Generalmente en los nombres de bases de datos se evita usar eñes o acentos para evitar problemas en los manejadores de las bases de datos.

lo gráficos de esta clase los hice en cuaderno

Empezamos en esta clase por crear la base de datos y luego crear las tablas, voy a poner el paso a paso tanto como lo hice con código como desde el gráfico

- Con código:

    CREATE DATABASE platziblog;
    USE platziblog;
    CREATE TABLE categorias(
        id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        nombre_categoria varchar(30) NOT NULL
    )

    CREATE TABLE etiquetas(
        id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        nombre_etiqueta varchar(30) NOT NULL
    )

    CREATE DATABASE platzi;
    USE platziblog;
    CREATE TABLE usuarios(
        id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        login VARCHAR(30) NOT NULL,
        password VARCHAR(32) NOT NULL,
        nickname VARCHAR(40) NOT NULL,
        email VARCHAR(40) NOT NULL UNIQUE
    );

- Desde el gráfico de MySQL:
    Cuando hago los pasos de ir al menú del lado izquierdo y todo eso, me arroja el siguiente comando

    CREATE TABLE `platzi`.`categorias` (
    `id` INT NOT NULL AUTO_INCREMENT,
    `nombre_categoria` VARCHAR(30) NOT NULL,
    PRIMARY KEY (`id`));

    CREATE TABLE `platzi`.`etiquetas` (
    `id` INT NOT NULL AUTO_INCREMENT,
    `nombre_etiqueta` VARCHAR(30) NOT NULL,
    PRIMARY KEY (`id`));

    CREATE TABLE `platzi`.`usuarios` (
    `id` INT NOT NULL AUTO_INCREMENT,
    `login` VARCHAR(30) NOT NULL,
    `password` VARCHAR(32) NOT NULL,
    `nickname` VARCHAR(40) NOT NULL,
    `email` VARCHAR(40) NOT NULL,
    PRIMARY KEY (`id`),
    UNIQUE INDEX `email_UNIQUE` (`email` ASC) VISIBLE);


***Clase 25 Creando Platziblog: tablas dependientes***

Tener cuidado con estas tablas porque tienen llaves foraneas en el ejemplo que estamos mirando es la relación que tiene
    Posts con usuarios_id y categorias_id
    Comentarios con usuarios_id y posts_id

    y se crean así

    no sé si está bien(aunque eso espero), pero mediante código lo hice así:

    CREATE TABLE posts (
        id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
        titulo VARCHAR(150) NOT NULL,
        fecha_publicacion TIMESTAMP,
        contenido TEXT NOT NULL,
        estado CHAR(8) DEFAULT('activo'),
        FOREIGN KEY(id) REFERENCES usuarios(id),
        FOREIGN KEY(id) REFERENCES categorias(id)
        ON DELETE NO ACTION
        ON UPDATE CASCADE
        );


El comando “cascade” sirve para que cada que se haga un update en la tabla principal, 
se refleje también en la tabla en la que estamos creando la relación.

Consultas a una base de datos

Colores de los atributos en la base de datos:
    - Blanco: Cuando estaba sin marcar el NOT NULL
    - Azul celeste: Cuando le marqué el NOT NULL
    - La llave si quiere decir que es un id

Creé la base de datos desde el gráfico y tener en cuenta que me arrojó este código

    CREATE TABLE `platzi`.`posts` (
    `id` INT NOT NULL AUTO_INCREMENT,
    `titulo` VARCHAR(150) NULL,
    `fecha_publicacion` TIMESTAMP NULL,
    `contenido` TEXT NOT NULL,
    `status` CHAR(8) NOT NULL DEFAULT 'activo',
    `usuario_id` INT NOT NULL,
    `categoria_id` INT NOT NULL,
    PRIMARY KEY (`id`));

En la parte de abajo del gráfico de Workbench hay una opción para agregar una Foreign Key

Las opciones que tienen estas llaves ON UPDATE:
    - CASCADE: Cada que se haga un update en esa otra tabla hágalo también en la tabla de acá
    - NO ACTION: No haga nada si se borra esa llave, borre los datos y ya
    - SET NULL: lo que hace es que cuando el usuario desaparezca en el lugar del usuario_id me va poner un NULL
    - RESTRICT: Lo que quiere decir es que cada que quieran borrar un usuario que tenga un blog posts asociado  va decir, No, no puedes
        borrar ese usuario hasta que no se borren sus blog posts y te asegures que no hay información

También está la relación que dice qué va pasar cuando se borre el usuario ON DELETE:
    - CASCADE: si borran el usuario se borran todos los posts que haya creado un usuario
    - SET NULL: lo que hace es que cuando el usuario desaparezca en el lugar del usuario_id me va poner un NULL
    - RESTRICT: Lo que quiere decir es que cada que quieran borrar un usuario que tenga un blog posts asociado  va decir, No, no puedes
        borrar ese usuario hasta que no se borren sus blog posts y te asegures que no hay información
    - NO ACTION: No haga nada si se borra esa llave, borre los datos y ya

la creación de la Foreign Key para la tabla platzi.posts y platzi.categorias

ALTER TABLE `platzi`.`posts` 
ADD INDEX `posts_usuarios_idx` (`usuario_id` ASC) VISIBLE;
;
ALTER TABLE `platzi`.`posts` 
ADD CONSTRAINT `posts_usuarios`
  FOREIGN KEY (`usuario_id`)
  REFERENCES `platzi`.`usuarios` (`id`)
  ON DELETE NO ACTION
  ON UPDATE CASCADE;

ALTER TABLE `platzi`.`posts` 
ADD INDEX `posts_categorias_idx` (`categoria_id` ASC) VISIBLE;
;
ALTER TABLE `platzi`.`posts` 
ADD CONSTRAINT `posts_categorias`
  FOREIGN KEY (`categoria_id`)
  REFERENCES `platzi`.`categorias` (`id`)
  ON DELETE NO ACTION
  ON UPDATE NO ACTION;

***Clase 26 Creando Platziblog: tablas transitivas***

<<<<<<< HEAD
El comando “cascade” sirve para que cada que se haga un update en la tabla principal,
se refleje también en la tabla en la que estamos creando la relación.

Las Foreing Key options son las siguientes:
=======
Creación de todas las tablas por medio de código con llaves foraneas

create database platziblog;
use platziblog;

CREATE TABLE categorias (
id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
nombre_categorias VARCHAR(30) NOT NULL
);

CREATE TABLE etiquetas (
id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
nombre_etiquetas VARCHAR(30) NOT NULL
);

CREATE TABLE usuarios (
id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
login VARCHAR(32) NOT NULL,
password VARCHAR(30) NOT NULL,
nickname VARCHAR(40) NOT NULL,
email CHAR(8) NOT NULL UNIQUE DEFAULT 'activo'
);

CREATE TABLE posts (
id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
titulo VARCHAR(150) NOT NULL,
fecha_publicacion TIMESTAMP NOT NULL,
contenido TEXT NOT NULL,
status CHAR(8) NOT NULL DEFAULT 'activo',
usuario_id INT NOT NULL,
categoria_id INT NOT NULL,
INDEX posts_categorias_idx (categoria_id ASC),
INDEX posts_usuarios_idx (usuario_id ASC),
CONSTRAINT posts_usuarios
FOREIGN KEY(usuario_id) 
REFERENCES platziblog.usuarios(id)
ON DELETE NO ACTION
ON UPDATE CASCADE,
CONSTRAINT posts_categorias
FOREIGN KEY(categoria_id)
REFERENCES platziblog.categorias(id)
ON DELETE NO ACTION
ON UPDATE CASCADE
);
use platziblog;
CREATE TABLE comentarios (
id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
cuerpo_comentario TEXT NOT NULL,
usuarios_id INT NOT NULL,
posts_id INT NOT NULL,
INDEX comentarios_usuarios_idx (usuarios_id ASC),
INDEX comentarios_posts_idx (posts_id ASC),
CONSTRAINT comentarios_usuarios
FOREIGN KEY(usuarios_id) 
REFERENCES platziblog.usuarios(id)
ON DELETE NO ACTION
ON UPDATE CASCADE,
CONSTRAINT comentarios_posts
FOREIGN KEY(posts_id)
REFERENCES platziblog.posts(id)
ON DELETE NO ACTION
ON UPDATE CASCADE
);

CREATE TABLE posts_etiquetas (
id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,
posts_id INT NOT NULL,
etiquetas_id INT NOT NULL,
INDEX postsetiquetas_etiquetas_idx (etiquetas_id ASC),
INDEX postsetiquetas_posts_idx (posts_id ASC),
CONSTRAINT postsetiquetas_etiquetas
FOREIGN KEY(etiquetas_id) 
REFERENCES platziblog.etiquetas(id)
ON DELETE NO ACTION
ON UPDATE CASCADE,
CONSTRAINT postsetiquetas_posts
FOREIGN KEY(posts_id)
REFERENCES platziblog.posts(id)
ON DELETE NO ACTION
ON UPDATE CASCADE
);
>>>>>>> 9141895ba2fb0e2b72ef3f64ab5231a9c63cf29a

On update: 

Significa qué pasará con las relaciones cuando una de estas sea modificada en sus campos relacionados, Por ejemplo, pueden utilizarse los valores:
    - cascade: Si el id de un usuario pasa de 11 a 12, entonces la relacion se actualizará y el post buscará el id nuevo en lugar de quedarse sin usuario.
    - restrict: _Si el id de un usuario pasa de 11 a 12, no lo permitirá hasta que no sean actualizados antes todos los post relacionados.
    - set null Si el id de un usuario pasa de 11 a 12, entonces los post solo no estará relacionados con nada.
    - no action: Si el id de un usuario pasa de 11 a 12, no se hará nada. Solo se romperá la relación.

On delete:
    - cascade: Si un usuario es eliminado entonces se borrarán todos los post relacionados.
    - restrict: No se podrá eliminar un usuario hasta que sean eliminados todos su post relacionados.
    - set null: Si un usuario es eliminado, entonces los post solo no estará relacionados con nada.
    - no action: Si un usuario es eliminado, no se hará nada. Solo se romperá la relación.

Las tablas transitivas sirven como puente para unir dos tablas. No tienen contenido semántico.
Reverse Engineer nos reproduce el esquema del cual nos basamos para crear nuestras tablas. 
Es útil cuando llegas a un nuevo trabajo y quieres entender cuál fue la mentalidad que tuvieron al momento de crear las bases de datos.

Creé la base de datos comentarios con código y lo hice así:
    USE platziblog;
    CREATE TABLE comentarios (
    id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
    cuerpo_comentario TEXT NOT NULL,
    usuario_id INT NOT NULL,
    post_id INT NOT NULL,
    FOREIGN KEY(id) REFERENCES usuarios(id),
    FOREIGN KEY(id) REFERENCES categorias(id)
    ON DELETE NO ACTION
    ON UPDATE CASCADE
    );

Creé la base de datos mediante el gráfico, con llaves foraneas y todo y me arrojó el siguiente código

CREATE TABLE `platzi`.`comentarios` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `cuerpo_comentario` TEXT NOT NULL,
  `usuario_id` INT NOT NULL,
  `post_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `comentarios_usuarios_idx` (`usuario_id` ASC) VISIBLE,
  INDEX `comentarios_posts_idx` (`post_id` ASC) VISIBLE,
  CONSTRAINT `comentarios_usuarios`
    FOREIGN KEY (`usuario_id`)
    REFERENCES `platzi`.`usuarios` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `comentarios_posts`
    FOREIGN KEY (`post_id`)
    REFERENCES `platzi`.`posts` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION);

Creé la base de datos transitiva que era posts_etiquetas con código y llaves foraneas y quedó así

    USE platziblog;
    CREATE TABLE posts_etiquetas (
    id INT PRIMARY KEY NOT NULL AUTO_INCREMENT,
    posts_id INT NOT NULL,
    etiquetas_id INT NOT NULL,
    FOREIGN KEY(id) REFERENCES posts(id),
    FOREIGN KEY(id) REFERENCES etiquetas(id)
    ON DELETE NO ACTION
    ON UPDATE CASCADE
    );

Creé la base de datos mediante el gráfico y me quedó así:

CREATE TABLE `platzi`.`posts_etiquetas` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `posts_id` INT NOT NULL,
  `etiquetas_id` INT NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `postsetiquetas_posts_idx` (`posts_id` ASC) VISIBLE,
  INDEX `postsetiquetas_etiquetas_idx` (`etiquetas_id` ASC) VISIBLE,
  CONSTRAINT `postsetiquetas_posts`
    FOREIGN KEY (`posts_id`)
    REFERENCES `platzi`.`posts` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `postsetiquetas_etiquetas`
    FOREIGN KEY (`etiquetas_id`)
    REFERENCES `platzi`.`etiquetas` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION);

***Clase 27 ¿Por qué las consultas son tan importantes?***

Las consultas o queries a una base de datos son una parte fundamental ya que esto podría salvar un negocio o empresa.
Alrededor de las consultas a las bases de datos se han creado varias especialidades como ETL o transformación de datos, 
business intelligence e incluso machine learning.

***Clase 28 Estructura básica de un Query***

Los queries son la forma en la que estructuramos las preguntas que se harán a la base de datos. 
Transforma preguntas en sintaxis.

El query tiene básicamente 2 partes: SELECT y FROM y puede aparecer una tercera como WHERE.

La estrellita o asterisco (*) quiere decir que vamos a seleccionar todo sin filtrar campos.

inserté estos datos para probar 

INSERT INTO categorias (id, nombre_categorias)
VALUES ('1', '1');

INSERT INTO posts (id, titulo, fecha_publicacion, contenido, status, usuario_id, categoria_id)
VALUES ('1', 'Mi primer post', '2021-03-04', 'hola amiguitos', 'activo', '1', '1');

INSERT INTO usuarios (id, login, password, nickname, email)
VALUES ('1', 'user1', 'userdos', 'userone', 'll@f.com');

ejemplo de consulta sencilla:

    SELECT * FROM posts WHERE fecha_publicacion < '2023'

    SELECT * FROM posts WHERE fecha_publicacion < '2022'

***Clase 29 SELECT***

SELECT se encarga de proyectar o mostrar datos.

El nombre de las columnas o campos que estamos consultando puede ser cambiado utilizando AS después del nombre del campo y poniendo el nuevo que queremos tener:
    SELECT titulo AS encabezado FROM posts;
Existe una función de SELECT para poder contar la cantidad de registros. 
Esa información (un número) será el resultado del query:
    SELECT COUNT(*) FROM posts;

ejemplos de consultas de la clase

    - select count(*) from posts;
    - select count(*) from categorias;
    - select titulo, status from posts;

***Clase 30 FROM***



***Clase 31 Utilizando la sentencia FROM***



***Clase 32 WHERE***



***Clase 33 Utilizando la sentencia WHERE nulo y no nulo***



***Clase 34 GROUP BY***



***Clase 35 ORDER BY y HAVING***



***Clase 36 El interminable agujero de conejo (Nested queries)***



***Clase 37 ¿Cómo convertir una pregunta en un query SQL?***



***Clase 38 Preguntándole a la base de datos***



***Clase 39 Consultando PlatziBlog***



Introducción a la bases de datos NO relacionales

***Clase 40 ¿Qué son y cuáles son los tipos de bases de datos no relacionales?***



***Clase 41 Servicios administrados y jerarquía de datos***



Manejo de modelos de datos en bases de datos no relacionales
***Clase 42 Top level collection con Firebase***



***Clase 43 Creando y borrando documentos en Firestore***



***Clase 44 Colecciones vs subcolecciones***



***Clase 45 Recreando Platziblog***



***Clase 46 Construyendo Platziblog en Firestore***



***Clase 47 Proyecto final: transformando tu proyecto en una db no relacional***



Bases de datos en la vida real

***Clase 48 Bases de datos en la vida real***



***Clase 49 Big Data***



***Clase 50 Data warehouse***



***Clase 51 Data mining***



***Clase 52 ETL***



***Clase 53 Business intelligence***



***Clase 54 Machine Learning***



***Clase 55 Data Science***



***Clase 56 ¿Por qué aprender bases de datos hoy?***



Bonus

***Clase 57 Bases de datos relacionales vs no relacionales***



***Clase 58 Elegir una base de datos***

apuntes:

Claro que si, mira, como el editor me pide una URL yo subo la imagen en https://imgur.com/ y la página me da la URL de la imagen
que es la que coloco en el editor. Mucha suerte, amigo.

IMPORTANTE:

Para cuando no quiero arrancar el MySQL Workbench que me sale un error de este tipo:
"mysql workbench could not acquire management access for administration"
voy en mi pc a: 
1. Servicios
2. Busco el servicio que tiene como nombre MySQL80
3. Si ese servicio no está en ejecución, con click derecho miro las opciones y le doy en Iniciar, y con eso corre el MySQL
4. En este enlace lo miré
    https://www.youtube.com/watch?v=gwNdzZ_Enok